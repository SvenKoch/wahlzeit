/*
 * Coordinate
 */
package org.wahlzeit.model.coordinate;

import java.util.HashMap;


/*
 * @PatternInstance(
 * 	patternName = "Value Object"
 * 	participants = {
 * 		"ValueObject"
 *  }
 * )
 */
public class SphericCoordinate extends AbstractCoordinate {
	
	// latitude and longitude in degrees
	private final double latitude;
	private final double longitude;
	// radius in km
	private final double radius;
	// Earth's radius in km
	public static final int EARTHRADIUS = 6371;
	
	private static HashMap<SphericCoordinate, SphericCoordinate> instances = new HashMap<SphericCoordinate, SphericCoordinate>();
	
	
	public static SphericCoordinate getInstance(double latitude, double longitude, double radius){
		SphericCoordinate coord = new SphericCoordinate(latitude, longitude, radius);
		// unsynchronized check, as we can get around locking, if the entry is already present within the HashMap (read-only)
		SphericCoordinate shared = instances.get(coord);
		if(shared == null){
			synchronized (instances) {
				// we need to check again, as the last check was not synchronized!
				shared = instances.get(coord);
				if(shared == null){
					shared = coord;
					instances.put(shared, shared);
				}
			}
		}
		return shared;
	}
	
	public static SphericCoordinate getInstance(double latitude, double longitude){
		return getInstance(latitude, longitude, EARTHRADIUS);
	}
	
	/**
	 * @methodtype constructor
	 * @param latitude latitude in degrees
	 * @param longitude longitude in degrees
	 * @param radius radius in km
	 */
	private SphericCoordinate(double latitude, double longitude, double radius){
		assertValidLatitude(latitude);
		assertValidLongitude(longitude);
		assertValidRadius(radius);
		this.latitude = latitude;
		this.longitude = longitude;
		this.radius = radius;
	}
		
	@Override
	public CartesianCoordinate asCartesianCoordinate() {
		double lat = Math.toRadians(this.latitude);
		double lon = Math.toRadians(this.longitude);
		double x = radius * Math.cos(lat) * Math.cos(lon);
		double y = radius * Math.cos(lat) * Math.sin(lon);
		double z = radius * Math.sin(lat);
		return CartesianCoordinate.getInstance(x,y,z);
	}
	
	/**
	 * @methodtype get
	 */
	public double getLatitude(){
		return latitude;
	}
	
	/**
	 * @methodtype get
	 */
	public double getLongitude(){
		return longitude;
	}

	private void assertValidLatitude(double latitude){
		if(latitude<-90 || latitude>90){
			throw new IllegalArgumentException("Valid values for latitude are: -90<=latitude<=90");
		}
	}
	
	private void assertValidLongitude(double longitude){
		if(longitude<-180 || longitude>180){
			throw new IllegalArgumentException("Valid values for longitude are: -180<=longitude<=180");
		}
	}
	
	private void assertValidRadius(double radius){
		if(!Double.isFinite(radius) || radius < 0){
			throw new IllegalArgumentException("Valid values for radius are: 0<=radius");
		}
	}
	
	
	/*
	 * generated by Eclipse
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		long temp;
		temp = Double.doubleToLongBits(latitude);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		temp = Double.doubleToLongBits(longitude);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		temp = Double.doubleToLongBits(radius);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		return result;
	}

	/*
	 * generated by Eclipse
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		SphericCoordinate other = (SphericCoordinate) obj;
		if (Double.doubleToLongBits(latitude) != Double.doubleToLongBits(other.latitude))
			return false;
		if (Double.doubleToLongBits(longitude) != Double.doubleToLongBits(other.longitude))
			return false;
		if (Double.doubleToLongBits(radius) != Double.doubleToLongBits(other.radius))
			return false;
		return true;
	}
}
